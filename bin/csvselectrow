#!/bin/bash
#set -euo pipefail

function failure {
  local lineno=$1
  local msg=$2
  echo "Failed at $lineno: $msg" 1>&2
}
trap 'failure ${LINENO} "$BASH_COMMAND"' ERR

VERSION="0.1.0"
PROGRAMNAME="csvselectrow"


function print_help {
  echo "\
$PROGRAMNAME $VERSION
Martijn Heil <m.heil375@gmail.com>
Copyright (c) 2021 Martijn Heil

Get value of first CSV row based on column name.
Input should be passed to stdin looking like this:
<HEADER> (newline)
<DATA ROW TO GET VALUE FROM> (newline) ...

USAGE:
    $PROGRAMNAME [FLAGS] [OPTIONS] <FILE>

FLAGS:
    -h, --help        Prints help information
    -v, --version     Prints version information
    -i, --interactive Use a interactive dialog."
}

function print_version {
  echo "$PROGRAMNAME v$VERSION"
}

# Check if enhanced getopt is available
! getopt --test > /dev/null
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
  echo "I'm sorry, `getopt --test` failed in this environment." >> /dev/stderr
  echo "This probably means that there is no enhanced getopt available." >> /dev/stderr
  exit 1
fi

OPTIONS=:n:i:d:h:v
LONGOPTS=:name:,index:,delim:,help,version

! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
  exit 2
fi

eval set -- "$PARSED"
# bounding polygon in Well Known Text (WKT), de coordinaten in RD
INTERACTIVE=false

while true; do
  case "$1" in
    -i|--interactive)
    INTERACTIVE=true
    ;;

    -h|--help)
    print_help
    exit 0
    ;;

    -v|--version)
    print_version
    exit 0
    ;;

    --)
    shift
    break
    ;;

    *)
    break
    #echo "Programming error" >> /dev/stderr
    #exit 3
    ;;
  esac
  shift
done

shift $(($OPTIND - 1))

tmpdir="$(mktemp -d)"

function cleanup {
  rm -rf "$tmpdir"
}

trap cleanup EXIT
cp "$1" "$tmpdir/input.csv"

rowcount=$(< "$tmpdir/input.csv" csvrowcount)
if [ "$rowcount" -le "1" ]; then
  cat "$tmpdir/input.csv"
  rm -rf "$tmpdir"
  exit 0
fi

< "$tmpdir/input.csv" csvsort -I -l > "$tmpdir/input_numbered.csv"

function do_line_based {
  < "$tmpdir/input_numbered.csv" sed -E '1 s/^line_number(.*)$/ROW NUMBER\1/' | csvlook -I >> /dev/stderr
  while : ; do
    echo -n "Select row number (press enter to abort selection): " >> /dev/stderr
    read -r num
    if [ "$num" = '' ]; then
      exit 2
    fi
    if [ "$num" -gt "$rowcount" ]; then
      echo "Invalid number $num, try again." >> /dev/stderr
      continue
    fi
    break
  done
}


if [ "$INTERACTIVE" = true ]; then
  # dialog doesn't like double quotes in the data.. as this is only for display to the user,
  # we replace all double quotes with two single quotes, as it looks somewhat similar and hopefully gets the intent across.
  < "$tmpdir/input_numbered.csv" csv2nix | tail -n +2 | sed "s/\"/''/g" | sed -E 's/^([0-9]*)(.*)$/\1 "\2"/' | sed -E 's/,/| /g' | csvquote -u > "$tmpdir/dialog_input.txt"

  # Awesome redirection hackery, it works!
  # Ignore the strange syntax highlighting.. it's valid anyhow
  num="$((dialog --column-separator '|' --menu "Choose one:" -1 -1 3 --file "$tmpdir/dialog_input.txt" 2>"$tmpdir/dialog_choice.txt" 2>&4 1>&3) 4>&1 3>&2)"
  exitcode=$?
  tput reset 1>&2
  if [ "$exitcode" = 255 ]; then # User pressed ESC
    exit 2
  fi

  if [ "$exitcode" != '0' ] && [ "$exitcode" != '1' ]; then
    echo "'dialog' exited with error code $exitcode, falling back on line-based selection mode." >> /dev/stderr
    sleep 1
    do_line_based
  fi

  if [ "$num" == '' ]; then
    exit 2
  fi
else
  do_line_based
fi

< "$tmpdir/input_numbered.csv" csvgrep -c "line_number" -r "^$num\$" | csvcut --not-columns 1
